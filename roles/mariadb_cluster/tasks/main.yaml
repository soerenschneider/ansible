---
- name: Create mariadb user
  ansible.builtin.user:
    name: "{{ mariadb_cluster_user }}"
    system: true
  tags: [mariadb, exporter, mysql, db]

- name: Create mariadb dir
  ansible.builtin.file:
    path: "{{ mariadb_cluster_base_dir }}"
    state: directory
    owner: "{{ mariadb_cluster_user }}"
    group: root
    mode: "0700"
  tags: [mariadb, mysql, db]

- name: Create mariadb storage dir
  ansible.builtin.file:
    path: "{{ mariadb_cluster_storage_dir }}"
    state: directory
    owner: "{{ mariadb_cluster_user }}"
    group: root
    mode: "0700"
  tags: [mariadb, mysql, db]

- name: Create mariadb certs dir
  ansible.builtin.file:
    path: "{{ mariadb_cluster_certs_dir }}"
    state: directory
    owner: "{{ mariadb_cluster_user }}"
    group: root
    mode: "0700"
  tags: [mariadb, mysql, db]

- name: Create mariadb dir storage
  ansible.builtin.template:
    src: templates/01-exporter.sql.j2
    dest: "{{ mariadb_cluster_base_dir }}/01-exporter.sql"
    owner: "{{ mariadb_cluster_user }}"
    group: "{{ mariadb_cluster_user }}"
    mode: "0700"
  tags: [mariadb, mysql, db]

- name: Add my.cnf
  ansible.builtin.copy:
    content: |
      [mariadb]
      ssl_cert = /certs/tls.crt
      ssl_key = /certs/tls.key
      require_secure_transport = ON
      [galera]
      wsrep_node_incoming_address={{ inventory_hostname }}
      wsrep_node_address={{ inventory_hostname }}
      wsrep-node-name={{ inventory_hostname }}
      {% if mariadb_cluster_preferred_donors | default([]) | length > 0 %}
      # NOTE: the comma at the end is not a typo, see https://fromdual.com/define-preferred-sst-donor-for-galera-cluster
      wsrep_sst_donor={{ mariadb_cluster_preferred_donors | join(',') }},
      {% endif %}
      wsrep_provider_options=socket.ssl=yes;socket.ssl_ca=/certs/wsrep-ca.crt;socket.ssl_cert=/certs/wsrep.crt;socket.ssl_key=/certs/wsrep.key;;ist.recv_addr={{ inventory_hostname }}:4568;ist.recv_bind=0.0.0.0:4568;
      [sst]
      tca=/certs/sst-ca.crt
      tcert=/certs/sst.crt
      encrypt=2
      [mariabackup]
      ssl-verify-server-cert = false
    dest: "{{ mariadb_cluster_base_dir }}/my.cnf"
    owner: root
    group: root
    mode: "0444"
  register: _mariadb_set_config
  tags: [mariadb, mysql, db]

- name: "Check connectivity"
  tags: [mariadb, connectivity]
  block:
    - name: Test connectivity to all hosts
      ansible.builtin.ping:
      register: ping_result
      ignore_errors: yes

    - name: Build list of online hosts
      ansible.builtin.set_fact:
        mariadb_cluster_online_hosts: "{{ mariadb_cluster_online_hosts + [inventory_hostname] }}"
      when: ping_result is succeeded

    - name: Aggregate online hosts across all hosts
      ansible.builtin.set_fact:
        _all_online_hosts: "{{ groups[group_names[0]] | map('extract', hostvars, 'mariadb_cluster_online_hosts') | select('defined') | flatten | unique | list }}"
      run_once: yes
      when: group_names | length > 0

    - name: Display connectivity results
      ansible.builtin.debug:
        msg: |
          Total hosts in group '{{ group_names[0] if group_names | length > 0 else 'ungrouped' }}': {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }}
          Online hosts: {{ _all_online_hosts | length }}
          Offline hosts: {{ (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length) - (_all_online_hosts | length) }}
          Online host list: {{ _all_online_hosts | sort }}
      run_once: yes

    - name: Check if ALL hosts are online
      ansible.builtin.assert:
        that:
          - _all_online_hosts | length == (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length)
        success_msg: "✅ SUCCESS: All {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts in the group are online"
        fail_msg: "❌ FAILURE: Not all hosts are online. {{ _all_online_hosts | length }}/{{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts are reachable"
      run_once: yes
      ignore_errors: yes
      register: all_hosts_check

    - name: Check if at least TWO hosts are online
      ansible.builtin.assert:
        that:
          - _all_online_hosts | length >= 2
        success_msg: "✅ SUCCESS: At least 2 hosts are online ({{ _all_online_hosts | length }} hosts reachable)"
        fail_msg: "❌ FAILURE: Less than 2 hosts are online (only {{ _all_online_hosts | length }} host(s) reachable)"
      run_once: yes
      ignore_errors: yes
      register: min_hosts_check

    - name: Final summary
      ansible.builtin.debug:
        msg: |
          ==================== CONNECTIVITY SUMMARY ====================
          Group: {{ group_names[0] if group_names | length > 0 else 'ungrouped' }}
          All hosts online: {{ 'YES' if all_hosts_check is succeeded else 'NO' }}
          At least 2 hosts online: {{ 'YES' if min_hosts_check is succeeded else 'NO' }}
          ============================================================
      run_once: yes

- name: Check certificate expiration for multiple certificates
  tags: [mariadb, certificates]
  block:
    - name: Get certificate expiration date
      ansible.builtin.command: openssl x509 -in "{{ item }}" -noout -enddate
      register: _cert_enddate
      changed_when: false
      loop: "{{ mariadb_cluster_certificate_paths }}"

    - name: Check if each certificate is expired using openssl
      ansible.builtin.command: openssl x509 -in "{{ item.item }}" -noout -checkend 0
      register: _cert_validity_check
      failed_when: false
      changed_when: false
      loop: "{{ _cert_enddate.results }}"

    - name: Build certificate status list
      ansible.builtin.set_fact:
        _cert_expired: "{{ _cert_expired | default([]) + [{'path': item.0.item, 'expired': item.1.rc != 0, 'expiry_date': item.0.stdout | regex_replace('notAfter=', '') | trim}] }}"
      loop: "{{ _cert_enddate.results | zip(_cert_validity_check.results) | list }}"

    - name: Display certificate status
      ansible.builtin.debug:
        msg: "Certificate {{ item.path }}: {{ 'EXPIRED' if item.expired else 'Valid' }} (expires: {{ item.expiry_date }})"
      loop: "{{ _cert_expired }}"

    - name: Fail if any certificate is expired
      ansible.builtin.fail:
        msg: |
          One or more certificates have expired:
          {% for cert in _cert_expired %}
          {% if cert.expired %}
          - {{ cert.path }}: expired {{ cert.expiry_date }}
          {% endif %}
          {% endfor %}
      when: _cert_expired | selectattr('expired', 'equalto', true) | list | length > 0

- name: Get container information
  tags: [mariadb, docker]
  block:
    - name: Get container information
      docker_container_info:
        name: "{{ mariadb_cluster_container_name }}"
      register: container_info

    - name: Display container status
      when: container_info.exists
      block:
        - name: Debug
          ansible.builtin.debug:
            msg: |
              Container: {{ mariadb_cluster_container_name }}
              State: {{ container_info.container.State.Status }}
              Running: {{ container_info.container.State.Running }}
              Restart Count: {{ container_info.container.RestartCount }}
              Started At: {{ container_info.container.State.StartedAt }}
          when: container_info.exists

        - name: Check if container is in restart loop
          ansible.builtin.debug:
            msg: "WARNING: Container {{ mariadb_cluster_container_name }} has restarted {{ container_info.container.RestartCount }} times"
          when: container_info.container.RestartCount | int > 5

        - name: Calculate uptime
          ansible.builtin.shell: |
            started_epoch=$(date -d "{{ container_info.container.State.StartedAt }}" +%s)
            current_epoch=$(date +%s)
            echo $((current_epoch - started_epoch))
          register: uptime_seconds
          when: container_info.container.State.Running
          changed_when: false

        - name: Set fact
          ansible.builtin.set_fact:
            uptime_seconds: "{{ uptime_seconds.stdout }}"
            uptime_minutes: "{{ uptime_seconds.stdout | int / 60 }}"
            running_and_stabilized: "{{ uptime_seconds.stdout | int / 60 >= 2 }}"
            running: "{{ uptime_seconds.stdout | int >= 0 }}"
          when: container_info.container.State.Running

        - name: Display uptime in human readable format
          ansible.builtin.debug:
            msg: "Container {{ mariadb_cluster_container_name }} has been running for {{ (uptime_seconds | int / 3600) | round(2) }} hours ({{ (uptime_seconds | int / 86400) | round(2) }} days)"
          when: container_info.container.State.Running

        - name: Gather all hosts that are already running
          ansible.builtin.set_fact:
            running_and_stabilized_instances: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[?running_and_stabilized].inventory_hostname') }}"
            running_instances: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[?running].inventory_hostname') }}"
          run_once: true

        - name: End playbook as all instances are running and stable
          ansible.builtin.meta: end_play
          when: _mariadb_set_config is not changed and groups[mariadb_cluster_ansible_group] | length == running_and_stabilized_instances | length

- name: Get UID for generated user
  ansible.builtin.getent:
    database: passwd
    key: "{{ mariadb_cluster_user }}"
  tags: always

- name: Build user string
  ansible.builtin.set_fact:
    _mariadb_cluster_user_string: "{{ getent_passwd[mariadb_cluster_user][1] }}"
  tags: always

- name: Create mariadb docker network
  community.docker.docker_network:
    name: "{{ mariadb_cluster_docker_network }}"
  tags: [docker, mariadb, mysql]

- name: Stop mariadb container as config has been updated
  community.docker.docker_container:
    name: "{{ mariadb_cluster_container_name }}"
    state: stopped
  when: _mariadb_set_config is changed and groups[mariadb_cluster_ansible_group] | length == running_and_stabilized_instances | length
  tags: [docker, mariadb, mysql]

- name: Check if it's safe to bootstrap existing cluster
  tags: [docker, mariadb, mysql]
  block:
    - name: "Check if 'safe_to_bootstrap: 1' is in grastate.dat"
      ansible.builtin.shell: |
        grep -Fxq "safe_to_bootstrap: 1" /var/lib/mariadb/data/data/grastate.dat
      register: bootstrap_check
      ignore_errors: true

    - name: Set per-host fact if safe to bootstrap
      ansible.builtin.set_fact:
        is_safe_to_bootstrap: "{{ bootstrap_check.rc == 0 }}"

    - name: Gather safe_to_bootstrap info from all nodes
      ansible.builtin.set_fact:
        bootstrap_candidates: "{{ groups.dbs | map('extract', hostvars) | list | json_query('[?is_safe_to_bootstrap].inventory_hostname') }}"
      run_once: true

    - name: "Set bootstrap_candidates"
      ansible.builtin.debug:
        var: bootstrap_candidates

    - name: "Set host_with_highest_number"
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ bootstrap_candidates[0] }}"
      run_once: true
      when: bootstrap_candidates | length > 0
      tags: [docker, mariadb, mysql]

    - name: "Print host_with_highest_number"
      ansible.builtin.debug:
        var: host_with_highest_number

- name: Run wsrep-recover
  when: bootstrap_candidates | length == 0 and container_info.exists
  tags: [docker, mariadb]
  block:
    - name: Figure out most recent commit
      community.docker.docker_container:
        name: "{{ mariadb_cluster_container_name }}"
        image: "{{ mariadb_cluster_image }}"
        restart_policy: "no"
        user: "{{ _mariadb_cluster_user_string }}"
        networks:
          - name: mariadb-cluster
        env:
          MARIADB_EXTRA_FLAGS: --wsrep_recover
          ALLOW_EMPTY_PASSWORD: "yes"
          TZ: UTC
        volumes: ["{{ mariadb_cluster_certs_dir }}:/certs:ro", "{{ mariadb_cluster_storage_dir }}:/bitnami/mariadb", /var/lib/mariadb/sst.cnf:/opt/bitnami/mariadb/conf/bitnami/my_custom.cnf]

    - name: Pause to Allow Container to Generate Logs
      ansible.builtin.pause:
        seconds: 5

    - name: Fetch logs
      ansible.builtin.command: "docker logs --since=1m {{ mariadb_cluster_container_name }}"
      changed_when: false
      register: container_logs

    - name: Find correct logline
      ansible.builtin.set_fact:
        relevant_log_line: "{{ container_logs.stdout_lines | select('search', 'Recovered position') | last }}"

    - name: Extract recovered position
      ansible.builtin.set_fact:
        extracted_number: "{{ relevant_log_line.split(':')[-1] }}"

    - name: Extracted position
      ansible.builtin.debug:
        var: extracted_number

    - name: "Map and set data for extracted position"
      ansible.builtin.set_fact:
        _data: "{{ groups.dbs | map('extract', hostvars) | list | json_query('[].{host: inventory_hostname, pos: extracted_number }') }}"

    - name: "Sort data"
      ansible.builtin.command: "python3 -c 'import sys, json; data = json.load(sys.stdin); sorted_data = sorted(data, key=lambda x: int(x[\"pos\"]), reverse=True); print(sorted_data[0][\"host\"])'"
      args:
        stdin: "{{ _data | to_json }}"
      changed_when: false
      register: _highest

    - name: Find Highest Extracted Number and Corresponding Host
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ _highest.stdout }}"
      run_once: true

    - name: Display Highest Extracted Number and Host
      ansible.builtin.debug:
        var: host_with_highest_number
      run_once: true

    - name: Set bootstrap variable
      ansible.builtin.lineinfile:
        path: "{{ mariadb_cluster_storage_dir }}/data/grastate.dat"
        regexp: "^safe_to_bootstrap:"
        line: "safe_to_bootstrap: 1"
      when: inventory_hostname == host_with_highest_number
  rescue:
    - name: No prior container exists
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ groups[mariadb_cluster_ansible_group][0] }}"
      tags: [docker, mariadb, mysql]

- name: Run master with startdb sql
  ansible.builtin.include_tasks: tasks/mariadb_run_master.yaml
  when: inventory_hostname == host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [docker, mariadb, mysql]

- name: Run slaves
  ansible.builtin.include_tasks: tasks/mariadb_run_slaves.yaml
  when: inventory_hostname != host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [docker, mariadb, mysql]

- name: Run initial master as slave
  ansible.builtin.include_tasks: tasks/mariadb_run_slaves.yaml
  when: inventory_hostname == host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [docker, mariadb, mysql]

- name: Run mysqld exporter
  community.docker.docker_container:
    name: "mysqld-exporter"
    image: "{{ mariadb_cluster_mysqld_exporter_image }}"
    user: "{{ _mariadb_cluster_user_string }}"
    restart_policy: "always"
    networks:
      - name: "{{ mariadb_cluster_docker_network }}"
    env:
      MYSQLD_EXPORTER_PASSWORD: "{{ mariadb_cluster_mysqld_exporter_password }}"
    command: |
      --mysqld.address={{ mariadb_cluster_container_name }}:3306
      --mysqld.username=exporter
      --tls.insecure-skip-verify
      --log.level=debug
    exposed_ports:
      - 9104
  tags: [mariadb, exporter, mysql]
