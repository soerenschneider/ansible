---
- name: Install mariadb
  ansible.builtin.include_tasks: install.yaml
  tags: always

- name: Configure mariadb
  ansible.builtin.include_tasks: configure.yaml
  tags: always

- name: Check certificates
  ansible.builtin.include_tasks: check_certs.yaml
  tags: always

- name: "Check connectivity"
  tags: [mariadb, connectivity]
  block:
    - name: Test connectivity to all hosts
      ansible.builtin.ping:
      register: ping_result
      ignore_errors: true

    - name: Build list of online hosts
      ansible.builtin.set_fact:
        mariadb_cluster_online_hosts: "{{ mariadb_cluster_online_hosts + [inventory_hostname] }}"
      when: ping_result is succeeded

    - name: Aggregate online hosts across all hosts
      ansible.builtin.set_fact:
        _all_online_hosts: "{{ groups[group_names[0]] | map('extract', hostvars, 'mariadb_cluster_online_hosts') | select('defined') | flatten | unique | list }}"
      run_once: true
      when: group_names | length > 0

    - name: Display connectivity results
      ansible.builtin.debug:
        msg: |
          Total hosts in group '{{ group_names[0] if group_names | length > 0 else 'ungrouped' }}': {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }}
          Online hosts: {{ _all_online_hosts | length }}
          Offline hosts: {{ (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length) - (_all_online_hosts | length) }}
          Online host list: {{ _all_online_hosts | sort }}
      run_once: true

    - name: Check if ALL hosts are online
      ansible.builtin.assert:
        that:
          - _all_online_hosts | length == (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length)
        success_msg: "✅ SUCCESS: All {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts in the group are online"
        fail_msg: "❌ FAILURE: Not all hosts are online. {{ _all_online_hosts | length }}/{{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts are reachable"
      run_once: true
      ignore_errors: true
      register: all_hosts_check

    - name: Check if at least TWO hosts are online
      ansible.builtin.assert:
        that:
          - _all_online_hosts | length >= 2
        success_msg: "✅ SUCCESS: At least 2 hosts are online ({{ _all_online_hosts | length }} hosts reachable)"
        fail_msg: "❌ FAILURE: Less than 2 hosts are online (only {{ _all_online_hosts | length }} host(s) reachable)"
      run_once: true
      ignore_errors: true
      register: min_hosts_check

    - name: Final summary
      ansible.builtin.debug:
        msg: |
          ==================== CONNECTIVITY SUMMARY ====================
          Group: {{ group_names[0] if group_names | length > 0 else 'ungrouped' }}
          All hosts online: {{ 'YES' if all_hosts_check is succeeded else 'NO' }}
          At least 2 hosts online: {{ 'YES' if min_hosts_check is succeeded else 'NO' }}
          ============================================================
      run_once: true

- name: Get container information
  tags: [mariadb]
  block:
    - name: Get container information
      community.docker.docker_container_info:
        name: "{{ mariadb_cluster_container_name }}"
      register: container_info

    - name: Display container status
      when: container_info.exists
      block:
        - name: Debug
          ansible.builtin.debug:
            msg: |
              Container: {{ mariadb_cluster_container_name }}
              State: {{ container_info.container.State.Status }}
              Running: {{ container_info.container.State.Running }}
              Restart Count: {{ container_info.container.RestartCount }}
              Started At: {{ container_info.container.State.StartedAt }}
          when: container_info.exists

        - name: Check if container is in restart loop
          ansible.builtin.debug:
            msg: "WARNING: Container {{ mariadb_cluster_container_name }} has restarted {{ container_info.container.RestartCount }} times"
          when: container_info.container.RestartCount | int > 5

        - name: Calculate uptime
          ansible.builtin.shell: |
            started_epoch=$(date -d "{{ container_info.container.State.StartedAt }}" +%s)
            current_epoch=$(date +%s)
            echo $((current_epoch - started_epoch))
          register: uptime_seconds
          when: container_info.container.State.Running
          changed_when: false

        - name: Set fact
          ansible.builtin.set_fact:
            uptime_seconds: "{{ uptime_seconds.stdout }}"
            uptime_minutes: "{{ uptime_seconds.stdout | int / 60 }}"
            running_and_stabilized: "{{ uptime_seconds.stdout | int / 60 >= 2 }}"  # at least running for 2 minutes
            running: "{{ uptime_seconds.stdout | int >= 0 }}"
          when: container_info.container.State.Running

        - name: Display uptime in human readable format
          ansible.builtin.debug:
            msg: "Container {{ mariadb_cluster_container_name }} has been running for {{ (uptime_seconds | int / 3600) | round(2) }} hours ({{ (uptime_seconds | int / 86400) | round(2) }} days)"
          when: container_info.container.State.Running

        - name: Gather all hosts that are already running
          ansible.builtin.set_fact:
            running_and_stabilized_instances: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[?running_and_stabilized].inventory_hostname') }}"
            running_instances: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[?running].inventory_hostname') }}"
          run_once: true

        - name: End playbook as all instances are running and stable
          ansible.builtin.meta: end_play
          when: _mariadb_set_config is not changed and groups[mariadb_cluster_ansible_group] | length == running_and_stabilized_instances | length

- name: Get UID for generated user
  ansible.builtin.getent:
    database: passwd
    key: "{{ mariadb_cluster_user }}"
  tags: [mariadb]

- name: Build user string
  ansible.builtin.set_fact:
    _mariadb_cluster_user_string: "{{ getent_passwd[mariadb_cluster_user][1] }}"
  tags: [mariadb]

- name: Create mariadb docker network
  community.docker.docker_network:
    name: "{{ mariadb_cluster_docker_network }}"
  tags: [mariadb]

- name: Stop mariadb container as config has been updated
  community.docker.docker_container:
    name: "{{ mariadb_cluster_container_name }}"
    state: stopped
  when: _mariadb_set_config is changed and groups[mariadb_cluster_ansible_group] | length == running_and_stabilized_instances | default([]) | length
  tags: [mariadb]

- name: Check if it's safe to bootstrap existing cluster
  tags: [mariadb]
  block:
    - name: "Check if 'safe_to_bootstrap: 1' is in grastate.dat"
      ansible.builtin.shell: |
        grep -Fxq "safe_to_bootstrap: 1" {{ mariadb_cluster_storage_dir }}/grastate.dat
      register: bootstrap_check
      changed_when: false
      ignore_errors: true

    - name: Set per-host fact if safe to bootstrap
      ansible.builtin.set_fact:
        is_safe_to_bootstrap: "{{ bootstrap_check.rc == 0 }}"

    - name: Gather safe_to_bootstrap info from all nodes
      ansible.builtin.set_fact:
        bootstrap_candidates: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[?is_safe_to_bootstrap].inventory_hostname') }}"
      run_once: true

    - name: "Set bootstrap_candidates"
      ansible.builtin.debug:
        var: bootstrap_candidates

    - name: "Set host_with_highest_number"
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ bootstrap_candidates[0] }}"
      run_once: true
      when: bootstrap_candidates | length > 0
      tags: [mariadb, mysql]

    - name: "Print host_with_highest_number"
      ansible.builtin.debug:
        var: host_with_highest_number

- name: Run wsrep-recover
  when: bootstrap_candidates | length == 0 and container_info.exists
  tags: [mariadb]
  block:
    - name: Figure out most recent commit
      community.docker.docker_container:
        name: "{{ mariadb_cluster_container_name }}"
        image: "{{ mariadb_cluster_image }}"
        restart_policy: "no"
        user: "{{ _mariadb_cluster_user_string }}"
        networks:
          - name: mariadb-cluster
        command: |
          --wsrep-recover
          --wsrep-cluster-address={{ mariadb_cluster_galera_cluster_address }}
        env:
          MARIADB_ALLOW_EMPTY_ROOT_PASSWORD: "yes"
          TZ: UTC
        volumes: ["{{ mariadb_cluster_certs_dir }}:/certs:ro", "{{ mariadb_cluster_storage_dir }}:/var/lib/mysql:Z", "/var/lib/mariadb/my.cnf:/etc/mysql/conf.d/galera.cnf"]

    - name: Pause to Allow Container to Generate Logs
      ansible.builtin.pause:
        seconds: 5

    - name: Fetch logs
      ansible.builtin.command: "docker logs --since=1m {{ mariadb_cluster_container_name }}"
      changed_when: false
      register: container_logs

    - name: Find correct logline
      ansible.builtin.set_fact:
        relevant_log_line: "{{ container_logs.stderr_lines | select('search', 'Recovered position') | last }}"

    - name: Extract recovered position
      ansible.builtin.set_fact:
        extracted_number: "{{ relevant_log_line.split(':')[-1] }}"

    - name: Extracted position
      ansible.builtin.debug:
        var: extracted_number

    - name: "Map and set data for extracted position"
      ansible.builtin.set_fact:
        _data: "{{ groups[mariadb_cluster_ansible_group] | map('extract', hostvars) | list | json_query('[].{host: inventory_hostname, pos: extracted_number }') }}"

    - name: "Sort data"
      ansible.builtin.command: "python3 -c 'import sys, json; data = json.load(sys.stdin); sorted_data = sorted(data, key=lambda x: int(x[\"pos\"]), reverse=True); print(sorted_data[0][\"host\"])'"
      args:
        stdin: "{{ _data | to_json }}"
      changed_when: false
      register: _highest

    - name: Find Highest Extracted Number and Corresponding Host
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ _highest.stdout }}"
      run_once: true

    - name: Display Highest Extracted Number and Host
      ansible.builtin.debug:
        var: host_with_highest_number
      run_once: true

    - name: Set bootstrap variable
      ansible.builtin.lineinfile:
        path: "{{ mariadb_cluster_storage_dir }}/grastate.dat"
        regexp: "^safe_to_bootstrap:"
        line: "safe_to_bootstrap: 1"
      when: inventory_hostname == host_with_highest_number
  rescue:
    - name: No prior container exists
      ansible.builtin.set_fact:
        host_with_highest_number: "{{ groups[mariadb_cluster_ansible_group][0] }}"
      tags: [mariadb, mysql]

- name: Run master with startdb sql
  ansible.builtin.include_tasks: tasks/run_master.yaml
  when: inventory_hostname == host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [mariadb, mysql]

- name: Run slaves
  ansible.builtin.include_tasks: tasks/run_slaves.yaml
  when: inventory_hostname != host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [mariadb, mysql]

- name: Run initial master as slave
  ansible.builtin.include_tasks: tasks/run_slaves.yaml
  when: inventory_hostname == host_with_highest_number | default(groups[mariadb_cluster_ansible_group][0])
  tags: [mariadb, mysql]

- name: Run mysqld exporter
  community.docker.docker_container:
    name: "mysqld-exporter"
    image: "{{ mariadb_cluster_mysqld_exporter_image }}"
    user: "{{ _mariadb_cluster_user_string }}"
    restart_policy: "always"
    networks:
      - name: "{{ mariadb_cluster_docker_network }}"
    env:
      MYSQLD_EXPORTER_PASSWORD: "{{ mariadb_cluster_mysqld_exporter_password }}"
    command: |
      --mysqld.address={{ mariadb_cluster_container_name }}:3306
      --mysqld.username=exporter
      --tls.insecure-skip-verify
      --log.level=debug
    ports:
      - "127.0.0.1:9104:9104"
  tags: [mariadb, exporter, mysql]
