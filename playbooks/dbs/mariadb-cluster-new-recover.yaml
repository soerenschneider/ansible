---
- name: Recover MariaDB cluster
  hosts: dbs
  become: true
  gather_facts: true
  vars:
    certificate_paths:
      - "{{ mariadb_certs_dir }}/ca.crt"
      - "{{ mariadb_certs_dir }}/sst-ca.crt"
      - "{{ mariadb_certs_dir }}/sst.crt"
      - "{{ mariadb_certs_dir }}/tls.crt"
      - "{{ mariadb_certs_dir }}/wsrep.crt"
      - "{{ mariadb_certs_dir }}/wsrep-ca.crt"
    online_hosts: []

  tasks:
    - name: "Check connectivity"
      tags: [connectivity]
      block:
        - name: Test connectivity to all hosts
          ansible.builtin.ping:
          register: ping_result
          ignore_errors: true

        - name: Build list of online hosts
          ansible.builtin.set_fact:
            online_hosts: "{{ online_hosts + [inventory_hostname] }}"
          when: ping_result is succeeded

        - name: Aggregate online hosts across all hosts
          ansible.builtin.set_fact:
            all_online_hosts: "{{ groups[group_names[0]] | map('extract', hostvars, 'online_hosts') | select('defined') | flatten | unique | list }}"
          run_once: true
          when: group_names | length > 0

        - name: Display connectivity results
          ansible.builtin.debug:
            msg: |
              Total hosts in group '{{ group_names[0] if group_names | length > 0 else 'ungrouped' }}': {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }}
              Online hosts: {{ all_online_hosts | length }}
              Offline hosts: {{ (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length) - (all_online_hosts | length) }}
              Online host list: {{ all_online_hosts | sort }}
          run_once: true

        - name: Check if ALL hosts are online
          ansible.builtin.assert:
            that:
              - all_online_hosts | length == (groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length)
            success_msg: "✅ SUCCESS: All {{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts in the group are online"
            fail_msg: "❌ FAILURE: Not all hosts are online. {{ all_online_hosts | length }}/{{ groups[group_names[0]] | length if group_names | length > 0 else groups['all'] | length }} hosts are reachable"
          run_once: true
          ignore_errors: true
          register: all_hosts_check

        - name: Check if at least TWO hosts are online
          ansible.builtin.assert:
            that:
              - all_online_hosts | length >= 2
            success_msg: "✅ SUCCESS: At least 2 hosts are online ({{ all_online_hosts | length }} hosts reachable)"
            fail_msg: "❌ FAILURE: Less than 2 hosts are online (only {{ all_online_hosts | length }} host(s) reachable)"
          run_once: true
          ignore_errors: true
          register: min_hosts_check

        - name: Final summary
          ansible.builtin.debug:
            msg: |
              ==================== CONNECTIVITY SUMMARY ====================
              Group: {{ group_names[0] if group_names | length > 0 else 'ungrouped' }}
              All hosts online: {{ 'YES' if all_hosts_check is succeeded else 'NO' }}
              At least 2 hosts online: {{ 'YES' if min_hosts_check is succeeded else 'NO' }}
              ============================================================
          run_once: true

    - name: Check certificate expiration for multiple certificates
      block:
        - name: Get certificate expiration date
          ansible.builtin.command: openssl x509 -in "{{ item }}" -noout -enddate
          register: _cert_enddate
          changed_when: false
          loop: "{{ certificate_paths }}"

        - name: Check if each certificate is expired using openssl
          ansible.builtin.command: openssl x509 -in "{{ item.item }}" -noout -checkend 0
          register: _cert_validity_check
          failed_when: false
          changed_when: false
          loop: "{{ _cert_enddate.results }}"

        - name: Build certificate status list
          ansible.builtin.set_fact:
            _cert_expired: "{{ _cert_expired | default([]) + [{'path': item.0.item, 'expired': item.1.rc != 0, 'expiry_date': item.0.stdout | regex_replace('notAfter=', '') | trim}] }}"
          loop: "{{ _cert_enddate.results | zip(_cert_validity_check.results) | list }}"

        - name: Display certificate status
          ansible.builtin.debug:
            msg: "Certificate {{ item.path }}: {{ 'EXPIRED' if item.expired else 'Valid' }} (expires: {{ item.expiry_date }})"
          loop: "{{ _cert_expired }}"

        - name: Fail if any certificate is expired
          ansible.builtin.fail:
            msg: |
              One or more certificates have expired:
              {% for cert in _cert_expired %}
              {% if cert.expired %}
              - {{ cert.path }}: expired {{ cert.expiry_date }}
              {% endif %}
              {% endfor %}
          when: _cert_expired | selectattr('expired', 'equalto', true) | list | length > 0

    - name: Get container information
      block:
        - name: Get container information
          community.docker.docker_container_info:
            name: "{{ mariadb_container_name }}"
          register: container_info

        - name: Display container status
          when: container_info.exists
          block:
            - name: Debug
              ansible.builtin.debug:
                msg: |
                  Container: {{ mariadb_container_name }}
                  State: {{ container_info.container.State.Status }}
                  Running: {{ container_info.container.State.Running }}
                  Restart Count: {{ container_info.container.RestartCount }}
                  Started At: {{ container_info.container.State.StartedAt }}
              when: container_info.exists

            - name: Check if container is in restart loop
              ansible.builtin.debug:
                msg: "WARNING: Container {{ mariadb_container_name }} has restarted {{ container_info.container.RestartCount }} times"
              when: container_info.container.RestartCount | int > 5

            - name: Calculate uptime
              ansible.builtin.shell: |
                started_epoch=$(date -d "{{ container_info.container.State.StartedAt }}" +%s)
                current_epoch=$(date +%s)
                echo $((current_epoch - started_epoch))
              register: uptime_seconds
              when: container_info.container.State.Running
              changed_when: false

            - name: Set fact
              ansible.builtin.set_fact:
                uptime_seconds: "{{ uptime_seconds.stdout }}"
                uptime_minutes: "{{ uptime_seconds.stdout | int / 60 }}"
                running_and_stabilized: "{{ uptime_seconds.stdout | int / 60 >= 2 }}"
              when: container_info.container.State.Running

            - name: Display uptime in human readable format
              ansible.builtin.debug:
                msg: "Container {{ mariadb_container_name }} has been running for {{ (uptime_seconds | int / 3600) | round(2) }} hours ({{ (uptime_seconds | int / 86400) | round(2) }} days)"
              when: container_info.container.State.Running

            - name: Gather all hosts that are already running
              ansible.builtin.set_fact:
                running_and_stabilized_instances: "{{ groups.dbs | map('extract', hostvars) | list | json_query('[?running_and_stabilized].inventory_hostname') }}"
              run_once: true

            - name: End playbook as all instances are running and stable
              ansible.builtin.meta: end_play
              when: groups.dbs | length == running_and_stabilized_instances | length


    - name: Get UID for generated user
      ansible.builtin.getent:
        database: passwd
        key: "{{ mariadb_user }}"
      tags: always

    - name: Build user string
      ansible.builtin.set_fact:
        _mariadb_user_string: "{{ getent_passwd[mariadb_user][1] }}"
        # _mariadb_user_string: "{{ getent_passwd[mariadb_pass][1] }}:{{ getent_passwd[mariadb_user][2] }}"
      tags: always

    - name: Create mariadb docker network
      community.docker.docker_network:
        name: mariadb-cluster
      tags: [docker, mariadb, mysql]

    - name: Check if it's safe to bootstrap
      tags: [docker, mariadb, mysql]
      block:
        - name: "Check if 'safe_to_bootstrap: 1' is in grastate.dat"
          ansible.builtin.shell: |
            grep -Fxq "safe_to_bootstrap: 1" /var/lib/mariadb/data/data/grastate.dat
          register: bootstrap_check
          changed_when: false
          ignore_errors: true

        - name: Set per-host fact if safe to bootstrap
          ansible.builtin.set_fact:
            is_safe_to_bootstrap: "{{ bootstrap_check.rc == 0 }}"

        - name: Gather safe_to_bootstrap info from all nodes
          ansible.builtin.set_fact:
            bootstrap_candidates: "{{ groups.dbs | map('extract', hostvars) | list | json_query('[?is_safe_to_bootstrap].inventory_hostname') }}"
          run_once: true

        - name: "Bootstrap candidates"
          ansible.builtin.debug:
            var: bootstrap_candidates

        - name: "Set host_with_highest_number"
          ansible.builtin.set_fact:
            host_with_highest_number: "{{ bootstrap_candidates[0] }}"
          run_once: true
          when: bootstrap_candidates | length > 0
          tags: [mariadb, mysql]
        - name: "Bootstrap candidates"
          ansible.builtin.debug:
            var: host_with_highest_number

    - name: Run wsrep-recover
      when: bootstrap_candidates | length == 0
      block:
        - name: Figure out most recent commit
          community.docker.docker_container:
            name: "{{ mariadb_mariadb_container_name }}"
            image: "{{ mariadb_image }}"
            restart_policy: "no"
            user: "{{ _mariadb_user_string }}"
            networks:
              - name: mariadb-cluster
            env:
              MARIADB_EXTRA_FLAGS: --wsrep_recover
              ALLOW_EMPTY_PASSWORD: "yes"
              TZ: UTC
            volumes: ["{{ mariadb_certs_dir }}:/certs:ro", "{{ mariadb_storage_dir }}:/bitnami/mariadb", /var/lib/mariadb/sst.cnf:/opt/bitnami/mariadb/conf/bitnami/my_custom.cnf]

        - name: Pause to Allow Container to Generate Logs
          ansible.builtin.pause:
            seconds: 5

        - name: Fetch logs
          ansible.builtin.command: docker logs --since=1m {{ mariadb_container_name }}
          changed_when: false
          register: container_logs

        - name: Find correct logline
          ansible.builtin.set_fact:
            relevant_log_line: "{{ container_logs.stdout_lines | select('search', 'Recovered position') | last }}"

        - name: Extract recovered position
          ansible.builtin.set_fact:
            extracted_number: "{{ relevant_log_line.split(':')[-1] }}"

        - name: Extracted position
          ansible.builtin.debug:
            var: extracted_number

        - name: "Map and set data for extracted position"
          ansible.builtin.set_fact:
            _data: "{{ groups.dbs | map('extract', hostvars) | list | json_query('[].{host: inventory_hostname, pos: extracted_number }') }}"

        - name: "Sort data"
          ansible.builtin.command: "python3 -c 'import sys, json; data = json.load(sys.stdin); sorted_data = sorted(data, key=lambda x: int(x[\"pos\"]), reverse=True); print(sorted_data[0][\"host\"])'"
          args:
            stdin: "{{ _data | to_json }}"
          changed_when: false
          register: _highest

        - name: Find Highest Extracted Number and Corresponding Host
          ansible.builtin.set_fact:
            host_with_highest_number: "{{ _highest.stdout }}"
          run_once: true

        - name: Display Highest Extracted Number and Host
          ansible.builtin.debug:
            var: host_with_highest_number
          run_once: true

        - name: Set bootstrap variable
          ansible.builtin.lineinfile:
            path: "{{ mariadb_storage_dir }}/data/grastate.dat"
            regexp: "^safe_to_bootstrap:"
            line: "safe_to_bootstrap: 1"
          when: inventory_hostname == host_with_highest_number
          tags: [docker, mariadb, mysql]

    - name: Run master with startdb sql
      ansible.builtin.include_tasks: tasks/mariadb_run_master.yaml
      when: inventory_hostname == host_with_highest_number
      tags: [docker, mariadb, mysql]

    - name: Run slaves
      ansible.builtin.include_tasks: tasks/mariadb_run_slaves.yaml
      when: inventory_hostname != host_with_highest_number
      tags: [docker, mariadb, mysql]

    - name: Run initial master as slave
      ansible.builtin.include_tasks: tasks/mariadb_run_slaves.yaml
      when: inventory_hostname == host_with_highest_number
      tags: [docker, mariadb, mysql]
